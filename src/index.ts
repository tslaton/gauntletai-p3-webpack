import { app, BrowserWindow, ipcMain, Menu, Tray, nativeImage, dialog, Notification, shell } from 'electron';
import path from 'node:path';
import fs from 'node:fs';
import os from 'node:os';
const Store = require('electron-store').default || require('electron-store');
import chokidar from 'chokidar';
import { createPDFPipeline, type PDFState } from './pipelines/pdfPipeline';
import { devLog, errorLog } from './utils/logger';
import { fetchOllamaModels } from './utils/ollama';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const store = new Store();
let mainWindow: BrowserWindow | null = null;
let tray: Tray | null = null;
let watcher: ReturnType<typeof chokidar.watch> | null = null;
// Track renamed files to avoid processing them again
const renamedFiles = new Set<string>();

// PDF processing queue to prevent concurrent processing
interface QueueItem {
  filePath: string;
  addedAt: Date;
}
const processingQueue: QueueItem[] = [];
let isProcessing = false;

// Pipeline instance - cached and reused
let pdfPipeline: ReturnType<typeof createPDFPipeline> | null = null;
let currentPipelineConfig = { openaiApiKey: '', llmModel: '', useLowercase: true, processingMode: 'accuracy' };

// Configuration
let WATCH_FOLDER = (store as any).get('watchFolder', path.join(os.homedir(), 'Documents', 'inbox')) as string;
let OPENAI_API_KEY = process.env.OPENAI_API_KEY || (store as any).get('openaiApiKey', '') as string;
let LLM_MODEL = process.env.LLM_MODEL || (store as any).get('llmModel', 'gpt-4.1-nano') as string;
let USE_LOWERCASE = (store as any).get('useLowercase', true) as boolean;
let PROCESSING_MODE = (store as any).get('processingMode', 'accuracy') as string; // 'accuracy' or 'speed'

// Log startup configuration
devLog('Startup configuration:');
devLog('- Watch folder:', WATCH_FOLDER);
devLog('- OpenAI API key:', OPENAI_API_KEY ? 'Set' : 'Not set');
devLog('- LLM Model:', LLM_MODEL);
devLog('- Use lowercase:', USE_LOWERCASE);
devLog('- Processing mode:', PROCESSING_MODE);

// Initialize pipeline with current config
function initializePipeline() {
  if (!pdfPipeline || 
      currentPipelineConfig.openaiApiKey !== OPENAI_API_KEY || 
      currentPipelineConfig.llmModel !== LLM_MODEL ||
      currentPipelineConfig.useLowercase !== USE_LOWERCASE ||
      currentPipelineConfig.processingMode !== PROCESSING_MODE) {
    devLog('Creating new PDF pipeline with updated configuration');
    devLog('API Key configured:', !!OPENAI_API_KEY);
    devLog('Model:', LLM_MODEL);
    devLog('Processing mode:', PROCESSING_MODE);
    mainWindow?.webContents.send('debug-log', `API Key: ${OPENAI_API_KEY ? 'Configured' : 'Not configured'}, Model: ${LLM_MODEL}`);
    
    pdfPipeline = createPDFPipeline(OPENAI_API_KEY, LLM_MODEL, USE_LOWERCASE, PROCESSING_MODE);
    currentPipelineConfig = { openaiApiKey: OPENAI_API_KEY, llmModel: LLM_MODEL, useLowercase: USE_LOWERCASE, processingMode: PROCESSING_MODE };
  }
  return pdfPipeline;
}

// Configuration will be used when processing PDFs

// Ensure watch folder exists
if (!fs.existsSync(WATCH_FOLDER)) {
  fs.mkdirSync(WATCH_FOLDER, { recursive: true });
}

const createWindow = () => {  
  // Create the browser window.
  mainWindow = new BrowserWindow({
    width: 900,
    height: 700,
    icon: app.isPackaged ? path.join(process.cwd(), 'src', 'assets', 'icon.png') : undefined,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      contextIsolation: true,
      nodeIntegration: false,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);
  
  // Wait for renderer to be ready
  mainWindow.webContents.on('did-finish-load', () => {
    console.log('[Main] Renderer did-finish-load event');
    mainWindow?.webContents.send('debug-log', 'Renderer loaded (did-finish-load)');
  });
  
  mainWindow.webContents.on('dom-ready', () => {
    console.log('[Main] Renderer dom-ready event');
    mainWindow?.webContents.send('debug-log', 'Renderer DOM ready');
  });

  mainWindow.on('close', (event) => {
    if (!app.isQuitting) {
      event.preventDefault();
      mainWindow?.hide();
    }
  });
  
  // Register DevTools shortcut
  mainWindow.webContents.on('before-input-event', (event, input) => {
    // On macOS, use Cmd+Shift+I; on other platforms use Ctrl+Shift+I
    const isMac = process.platform === 'darwin';
    const modifierPressed = isMac ? input.meta : input.control;
    
    if (input.key.toLowerCase() === 'i' && input.shift && modifierPressed) {
      event.preventDefault();
      mainWindow?.webContents.toggleDevTools();
    }
  });
  
};

const createTray = () => {
  const icon = nativeImage.createEmpty();
  tray = new Tray(icon);
  
  const contextMenu = Menu.buildFromTemplate([
    { 
      label: 'Show App', 
      click: () => {
        mainWindow?.show();
      } 
    },
    { 
      label: 'Open PDF Folder', 
      click: () => {
        shell.openPath(WATCH_FOLDER);
      } 
    },
    { type: 'separator' },
    { 
      label: 'Quit', 
      click: () => {
        app.isQuitting = true;
        app.quit();
      } 
    }
  ]);
  
  tray.setToolTip('File Wrangler');
  tray.setContextMenu(contextMenu);
  
  tray.on('click', () => {
    mainWindow?.show();
  });
};

// Setup file watcher
const setupWatcher = () => {
  if (watcher) {
    watcher.close();
  }
  
  devLog('Setting up watcher for folder:', WATCH_FOLDER);
  
  // Send debug info to renderer
  mainWindow?.webContents.send('debug-log', `Setting up watcher for: ${WATCH_FOLDER}`);
  
  // Watch the folder itself, not a glob pattern
  watcher = chokidar.watch(WATCH_FOLDER, {
    persistent: true,
    ignoreInitial: true,
    // Force polling on all platforms for consistency
    usePolling: true,
    interval: 500, // More frequent polling
    binaryInterval: 500,
    alwaysStat: true,
    depth: 0,
    awaitWriteFinish: {
      stabilityThreshold: 1000,
      pollInterval: 100
    }
  });
  
  watcher.on('add', async (filePath: string) => {
    // Only process PDF files
    if (path.extname(filePath).toLowerCase() !== '.pdf') {
      return;
    }
    
    // Skip if this is a file we renamed (avoid reprocessing our output)
    if (renamedFiles.has(filePath)) {
      devLog('Skipping renamed file:', filePath);
      renamedFiles.delete(filePath); // Clean up after detection
      return;
    }
    
    devLog('PDF detected:', filePath);
    mainWindow?.webContents.send('pdf-added', filePath);
    
    if (PROCESSING_MODE === 'speed') {
      // Parallel processing - process immediately
      devLog('Processing in parallel mode (speed)');
      processPDFFile(filePath).catch(error => {
        errorLog('Error processing PDF:', error);
        mainWindow?.webContents.send('processing-update', {
          path: filePath,
          status: 'error',
          error: error instanceof Error ? error.message : 'Unknown error'
        });
      });
    } else {
      // Sequential processing - use queue
      devLog('Processing in sequential mode (accuracy)');
      processingQueue.push({
        filePath,
        addedAt: new Date()
      });
      
      devLog(`Added to queue: ${filePath} (Queue size: ${processingQueue.length})`);
      
      // Start processing the queue
      processQueue();
    }
  });
  
  watcher.on('error', (error: Error) => {
    errorLog('Watcher error:', error);
    mainWindow?.webContents.send('debug-log', `Watcher error: ${error.message}`);
  });
  
  watcher.on('ready', () => {
    devLog('Watcher is ready and monitoring for PDF files');
    mainWindow?.webContents.send('debug-log', 'Watcher is ready and monitoring for PDF files');
  });
  
  // Also watch for all events to debug
  watcher.on('all', (event: string, filePath: string) => {
    devLog('Watcher event:', event, filePath);
    mainWindow?.webContents.send('debug-log', `Watcher event: ${event} ${path.basename(filePath)}`);
  });
  
  devLog('Watching folder:', WATCH_FOLDER);
  
  // Test if we can access the folder
  try {
    const files = fs.readdirSync(WATCH_FOLDER);
    devLog('Files in watch folder:', files);
    mainWindow?.webContents.send('debug-log', `Found ${files.length} files in watch folder`);
  } catch (error: any) {
    errorLog('Cannot read watch folder:', error);
    mainWindow?.webContents.send('debug-log', `Cannot read watch folder: ${error}`);
    
    // If permission denied, show a dialog to help user
    if (error.code === 'EPERM' || error.code === 'EACCES') {
      dialog.showMessageBox(mainWindow!, {
        type: 'warning',
        title: 'Folder Access Required',
        message: 'File Wrangler needs permission to access your Documents folder.',
        detail: 'Please grant access when prompted, or go to System Preferences > Security & Privacy > Privacy > Files and Folders and grant access to File Wrangler.',
        buttons: ['OK', 'Choose Different Folder']
      }).then(result => {
        if (result.response === 1) {
          // Let user choose a different folder
          ipcMain.emit('select-folder');
        }
      });
    }
  }
};

// Note: PDF conversion now happens in main process with pdf2img-electron

// IPC handlers
ipcMain.handle('get-config', () => ({
  watchFolder: WATCH_FOLDER,
  openaiApiKey: OPENAI_API_KEY,
  llmModel: LLM_MODEL,
  useLowercase: USE_LOWERCASE,
  processingMode: PROCESSING_MODE,
}));

ipcMain.handle('update-config', (_event, config) => {
  const oldWatchFolder = WATCH_FOLDER;
  
  if (config.watchFolder) {
    (store as any).set('watchFolder', config.watchFolder);
    WATCH_FOLDER = config.watchFolder;
  }
  if (config.openaiApiKey) {
    (store as any).set('openaiApiKey', config.openaiApiKey);
    OPENAI_API_KEY = config.openaiApiKey;
  }
  if (config.llmModel) {
    (store as any).set('llmModel', config.llmModel);
    LLM_MODEL = config.llmModel;
  }
  if (config.useLowercase !== undefined) {
    (store as any).set('useLowercase', config.useLowercase);
    USE_LOWERCASE = config.useLowercase;
  }
  if (config.processingMode) {
    (store as any).set('processingMode', config.processingMode);
    PROCESSING_MODE = config.processingMode;
  }
  
  // Restart watcher if folder changed
  if (config.watchFolder && config.watchFolder !== oldWatchFolder) {
    devLog('Watch folder changed from', oldWatchFolder, 'to', config.watchFolder);
    
    // Ensure new watch folder exists
    if (!fs.existsSync(WATCH_FOLDER)) {
      devLog('Creating new watch folder:', WATCH_FOLDER);
      fs.mkdirSync(WATCH_FOLDER, { recursive: true });
    }
    
    setupWatcher();
  }
  
  // Reinitialize pipeline if API key, model, lowercase setting, or processing mode changed
  if ((config.openaiApiKey && config.openaiApiKey !== currentPipelineConfig.openaiApiKey) ||
      (config.llmModel && config.llmModel !== currentPipelineConfig.llmModel) ||
      (config.useLowercase !== undefined && config.useLowercase !== currentPipelineConfig.useLowercase) ||
      (config.processingMode && config.processingMode !== currentPipelineConfig.processingMode)) {
    pdfPipeline = null; // Force recreation on next use
  }
  
  return true;
});

ipcMain.handle('select-folder', async () => {
  const result = await dialog.showOpenDialog(mainWindow!, {
    properties: ['openDirectory']
  });
  
  if (!result.canceled) {
    return result.filePaths[0];
  }
  return null;
});

ipcMain.handle('show-notification', (_event, title: string, body: string) => {
  new Notification({ title, body }).show();
});

ipcMain.handle('open-folder', () => {
  shell.openPath(WATCH_FOLDER);
});

ipcMain.handle('get-ollama-models', async () => {
  try {
    const models = await fetchOllamaModels();
    return models;
  } catch (error) {
    errorLog('Failed to fetch Ollama models:', error);
    return [];
  }
});

ipcMain.handle('process-pdf', async (_event, filePath: string) => {
  return processPDFFile(filePath);
});

// Note: PDF conversion now happens directly in main process

// Handle debug messages from renderer
ipcMain.on('renderer-debug', (_event, message: string) => {
  devLog('[Renderer Debug]:', message);
  mainWindow?.webContents.send('debug-log', `[Renderer] ${message}`);
});

// Note: pdf2img-electron reads files directly, so we don't need the read-pdf-file handler anymore

// Process PDFs from the queue sequentially
async function processQueue() {
  if (isProcessing || processingQueue.length === 0) {
    return;
  }
  
  isProcessing = true;
  
  while (processingQueue.length > 0) {
    const item = processingQueue.shift();
    if (!item) continue;
    
    try {
      await processPDFFile(item.filePath);
    } catch (error) {
      errorLog('Failed to process PDF:', item.filePath, error);
      mainWindow?.webContents.send('processing-update', {
        path: item.filePath,
        status: 'error',
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    }
  }
  
  isProcessing = false;
}

// Helper function to process PDF
async function processPDFFile(filePath: string) {
  const pipeline = initializePipeline();
  
  const initialState: PDFState = {
    path: filePath
  };
  
  let currentState: PDFState = initialState;
  
  // Send initial state
  mainWindow?.webContents.send('processing-update', { ...currentState });
  
  // Run the pipeline
  const stream = await pipeline.stream(initialState as any);
  
  for await (const chunk of stream) {
    // Update state with each step's output
    const [nodeName, nodeOutput] = Object.entries(chunk)[0];
    currentState = { ...currentState, ...(nodeOutput as Partial<PDFState>) } as PDFState;
    
    // Debug log for each step
    devLog(`Pipeline step: ${nodeName}`, nodeOutput);
    
    // Send debug info about what happened in this step
    const output = nodeOutput as Partial<PDFState>;
    if (nodeName === 'parse') {
      mainWindow?.webContents.send('debug-log', `Parse: ${output.rawText ? `Got ${output.rawText.length} chars` : 'No text'}`);
    } else if (nodeName === 'llm') {
      mainWindow?.webContents.send('debug-log', `LLM: ${output.meta ? 'Got metadata' : output.error || 'No metadata returned'}`);
    } else if (nodeName === 'rename') {
      mainWindow?.webContents.send('debug-log', `Rename: ${output.newPath ? 'Success' : output.error || 'Failed'}`);
    }
    
    if (currentState.error) {
      devLog(`Error in ${nodeName}:`, currentState.error);
      mainWindow?.webContents.send('debug-log', `Error in ${nodeName}: ${currentState.error}`);
    }
    
    // Map node names to status
    let status: string;
    switch (nodeName) {
      case 'parse':
        status = 'parsing';
        break;
      case 'llm':
        status = 'extracting';
        break;
      case 'rename':
        status = currentState.error ? 'error' : 'completed';
        break;
      default:
        status = 'processing';
    }
    
    mainWindow?.webContents.send('processing-update', {
      ...currentState,
      status,
      originalPath: filePath,
    });
  }
  
  if (currentState.newPath) {
    // Add the new path to renamed files to avoid reprocessing
    renamedFiles.add(currentState.newPath);
    
    // Log the rename for debugging
    devLog(`PDF renamed: ${path.basename(filePath)} → ${path.basename(currentState.newPath)}`);
    
    new Notification({
      title: 'PDF Renamed',
      body: `${path.basename(filePath)} → ${path.basename(currentState.newPath)}`
    }).show();
  }
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
app.on('ready', async () => {
  devLog('App ready, initializing...');
  
  // Set dock icon for macOS in development
  if (process.platform === 'darwin' && !app.isPackaged) {
    const dockIconPath = path.join(process.cwd(), 'src', 'assets', 'icon.png');
    if (fs.existsSync(dockIconPath)) {
      app.dock.setIcon(dockIconPath);
      devLog('Set dock icon:', dockIconPath);
    } else {
      devLog('Dock icon not found at:', dockIconPath);
    }
  }
  
  createWindow();
  createTray();
  
  // Wait a bit for window to be ready before setting up watcher
  // This helps ensure IPC is ready for debug messages
  setTimeout(() => {
    setupWatcher();
    devLog('App initialization complete');
  }, 1000);
});

// Quit when all windows are closed.
app.on('window-all-closed', () => {
  app.quit();
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  } else {
    mainWindow?.show();
  }
});

// Extend the app object for the close event
declare global {
  namespace Electron {
    interface App {
      isQuitting?: boolean;
    }
  }
}

// Cleanup function
function cleanup() {
  devLog('Cleaning up before exit...');
  
  // Close file watcher
  if (watcher) {
    watcher.close();
    watcher = null;
  }
  
  // Destroy tray
  if (tray) {
    tray.destroy();
    tray = null;
  }
  
  // Close all windows
  BrowserWindow.getAllWindows().forEach(window => {
    window.destroy();
  });
}

// Handle process termination signals
process.on('SIGINT', () => {
  devLog('Received SIGINT, cleaning up...');
  cleanup();
  app.quit();
});

process.on('SIGTERM', () => {
  devLog('Received SIGTERM, cleaning up...');
  cleanup();
  app.quit();
});

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  errorLog('Uncaught exception:', error);
  cleanup();
  app.quit();
});

// Handle app quit
app.on('before-quit', () => {
  devLog('App is quitting...');
  cleanup();
});